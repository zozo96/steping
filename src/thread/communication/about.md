### 线程间通信
与网络通信等进程通信方式不一样。线程间通信，可以被称为进程内通信，`多个线程互斥访问共享资源时会互相发送信号或等待信号`

#### 同步阻塞与异步非阻塞
- 同步阻塞消息处理。即事件Event是由一个线程完成，客户端需要等待接口返回响应。比如查多家航空公司的飞机票，需要等查完一家的接口给出响应再去查另一家，每个事件都会被阻塞进行，耗时较久。
- 异步非阻塞消息处理。即事件Event可以放置在队列中，为每个Event都返回一个No，客户端后续可以根据该No进行响应结果查询。同样查多家航空公司的飞机票，我们可以同时查询多家接口，最终将数据汇总到客户端。
#### 单线程间通信
比如，服务端有若干个线程会从队列中获取相应的Event进行异步处理，线程如何从队列中取数据呢或者说线程怎么知道队列中有没有数据，笨方法就是轮询，较好的是通知机制（wait & notify）
- wait()
    - 可中断方法，其他线程可以使用interrupt方法将其打断，并擦出interrupt标识。
    - wait() 即调用wait(0)表明永不超时 
    - wait(long timeout)，方法会导致当前线程进入阻塞，直至其他线程调用notify()或notifyAll()，或阻塞时间达到了timeout 而自动唤醒
    - 调用wait方法的线程必须拥有该对象的monitor，也就是wait方法必须在同步方法中使用
    - 调用wait方法的线程在执行完wait之后，会放弃对该monitor的所有权，并进入与该对象关联的wait set中，与其他线程一样继续争抢该monitor
- notify()
    - 唤醒某个正在执行该对象wait方法的线程
    - 被唤醒的线程需要重新获取与该对象所关联的monitor的lock，才可继续执行
- 必须在同步方法中使用wait和notify，并且同步代码的monitor必须与执行wait和notify方法的对象一致（尤其注意monitor为this和Class时）。
- wait 和 sleep
    - 都可以使线程进入阻塞状态
    - 均为可中断方法，被中断后都会收到中断异常
    - wait是Object的方法，sleep是Thread的方法
    - wait必须在同步方法中执行，sleep不需要
    - 线程在同步方法中执行sleep并不会释放当前monitor的锁，但执行wait会释放
    - 线程执行sleep方法休眠结束会主动退出阻塞，而wait(0)方法需要其他线程中断才能退出
#### 多线程间通信
#### 自定义显式锁BooleanLock